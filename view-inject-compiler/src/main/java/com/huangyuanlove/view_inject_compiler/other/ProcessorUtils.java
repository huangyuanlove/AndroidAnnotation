package com.huangyuanlove.view_inject_compiler.other;


import com.huangyuanlove.view_inject_annotation.BindView;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;

public class ProcessorUtils {

    private static final String JAVA_DOC = "Generated by apt. Do not modify!\n";
    private static final String SUFFIX = "$$InjectView";

    private Messager messager;
    private Elements elementUtils;
    private Filer filer;


    //不同的宿主，对应不同的TypeSpec
    private Map<String, TypeSpec.Builder> proxyTypeSpecMap = new HashMap<>();

    //不同类中会有不同的方法,第一个String类型，第二个String方法名
    private Map<String, HashMap<String, MethodSpec.Builder>> proxyMethodSpecMap = new HashMap<>();

    public ProcessorUtils(Messager messager, Elements elementUtils,Filer filer) {
        this.messager = messager;
        this.elementUtils = elementUtils;
        this.filer = filer;
    }


    public void process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {

        proxyTypeSpecMap.clear();
        proxyMethodSpecMap.clear();

        Set<? extends Element> elements = roundEnvironment.getElementsAnnotatedWith(BindView.class);


        for (Element element : elements) {


            //获取注解所在的类名
            String hostName = element.getEnclosingElement().toString();
            System.out.println("---hostName---");
            System.out.println(hostName);

            String viewInjectClassName = element.getEnclosingElement().getSimpleName().toString() + SUFFIX;
            System.out.println("---hostInjectName---");
            System.out.println(viewInjectClassName);

            String fieldName = element.getSimpleName().toString();
            System.out.println("---host field name---");
            System.out.println(fieldName);

            String typeName =   element.asType().toString();
            System.out.println("---host field type---");
            System.out.println(typeName);

            String packageName = elementUtils.getPackageOf(element.getEnclosingElement()).getQualifiedName().toString();
            System.out.println("--- packageName name---");
            System.out.println(packageName);

            BindView bindView = element.getAnnotation(BindView.class);
            System.out.println("---BindView value---");
            System.out.println(bindView.id());
            System.out.println(bindView.idStr());


            ClassName injectViewParam = ClassName.get((TypeElement) element.getEnclosingElement());
            System.out.println("---injectViewParam value---");
            System.out.println(injectViewParam.simpleName());


            System.out.println("-----------\n\n");


            //生成类
            TypeSpec.Builder typeSpecBuilder = proxyTypeSpecMap.get(hostName);
            if (typeSpecBuilder == null) {

                ClassName superClass=   ClassName.get("com.huangyuanlove.view_inject_api", "ViewInject");


                typeSpecBuilder = TypeSpec.classBuilder(viewInjectClassName)
                        .addSuperinterface(ParameterizedTypeName.get(superClass, TypeName.get(element.getEnclosingElement().asType())))
                        .addJavadoc(JAVA_DOC);
                proxyTypeSpecMap.put(hostName, typeSpecBuilder);
            }
            //生成方法
            HashMap<String, MethodSpec.Builder> methodSpecBuilderMap = proxyMethodSpecMap.get(hostName +".inject");
            if (methodSpecBuilderMap == null) {
                methodSpecBuilderMap = new HashMap<>();
                proxyMethodSpecMap.put(hostName+".inject", methodSpecBuilderMap);
            }



            VariableElement variableElement = (VariableElement) element;
            TypeElement classElement = (TypeElement) variableElement.getEnclosingElement();
            ClassName paramsWrapper = ClassName.get(classElement);

            MethodSpec.Builder methodBuilder =  methodSpecBuilderMap.get(hostName+".inject");

            if(methodBuilder == null) {
                methodBuilder = MethodSpec.methodBuilder("inject")
                        .addAnnotation(Override.class)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(void.class)
                        .addParameter(paramsWrapper, "host");

                methodSpecBuilderMap.put(hostName+".inject", methodBuilder);
            }
            methodBuilder.addCode(code(variableElement.getAnnotation(BindView.class),fieldName,typeName).toString());




            checkAnnotationValid(element, BindView.class);


        }

        //循环完成后，应该有两个辅助类，每个辅助类里面有一个方法
        for(Map.Entry<String,TypeSpec.Builder> entry : proxyTypeSpecMap.entrySet()){
           String key = entry.getKey();
           TypeSpec.Builder typeSpecBuilder = entry.getValue();


           HashMap<String,MethodSpec.Builder> methodSpecMap = proxyMethodSpecMap.get(key+".inject");
           if(methodSpecMap!=null && methodSpecMap.size()>0){
               for(Map.Entry<String,MethodSpec.Builder> methodSpecEntry:methodSpecMap.entrySet()){
                   typeSpecBuilder.addMethod(methodSpecEntry.getValue().build());
               }
           }

        }

        for(Map.Entry<String,TypeSpec.Builder> entry : proxyTypeSpecMap.entrySet()){

            TypeSpec typeSpec = entry.getValue().build();

            System.out.println(typeSpec);
            try {
                String key = entry.getKey();
                String packageName = key.substring(0,key.lastIndexOf("."));
                System.out.println(packageName);
                JavaFile javaFile = JavaFile.builder("com.huangyuanlove", typeSpec)
                        .build();
                javaFile.writeTo(filer);

            }catch (Exception e){
                e.printStackTrace();
            }

        }







    }


    private StringBuilder code(BindView inject, String name, String type) {
        StringBuilder builder = new StringBuilder();

        return builder;
    }


    private boolean checkAnnotationValid(Element annotatedElement, Class clazz) {
        if (annotatedElement.getKind() != ElementKind.FIELD) {
            error(annotatedElement, "%s must be declared on field.", clazz.getSimpleName());
            return false;
        }
        if (annotatedElement.getModifiers().contains(Modifier.PRIVATE)) {
            error(annotatedElement, "%s() must can not be private.", annotatedElement.getSimpleName());
            return false;
        }

        return true;
    }

    private void error(Element element, String message, Object... args) {
        if (args.length > 0) {
            message = String.format(message, args);
        }
        messager.printMessage(Diagnostic.Kind.ERROR, message, element);
    }
}
